{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> ALL-INCLUSIVE PYTHON PROJECTS </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Pyprojectx makes it easy to create all-inclusive Python projects; no need to install any tools upfront, not even Pyprojectx itself!</p>"},{"location":"#feature-highlights","title":"Feature highlights","text":"<ul> <li>Reproducible builds by treating tools and utilities as (versioned) dev-dependencies</li> <li>No global installs, everything is stored inside your project directory (like npm's node_modules)</li> <li>Bootstrap your entire build process with a small wrapper script (like Gradle's gradlew wrapper)</li> <li>Configure shortcuts for routine tasks</li> <li>Simple configuration in pyproject.toml</li> </ul> <p>Projects can be build/tested/used immediately without explicit installation nor initialization:</p> Linux/MacWindows <pre><code>git clone https://github.com/pyprojectx/px-demo.git\n# for the poetry version: git checkout poetry\ncd px-demo\n./pw build\n</code></pre> <pre><code>git clone https://github.com/pyprojectx/px-demo.git\n# for the poetry version: git checkout poetry\ncd px-demo\npw build\n</code></pre> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>One of the key features is that there is no need to install anything explicitly (except a Python 3.8+ interpreter).</p> <p><code>cd</code> into your project directory and download the wrapper scripts:</p> Linux/MacWindows <pre><code>curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip &amp;&amp; unzip -o wrappers.zip &amp;&amp; rm -f wrappers.zip\n</code></pre> <pre><code>Invoke-WebRequest https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip -OutFile wrappers.zip; Expand-Archive -Force -Path wrappers.zip -DestinationPath .; Remove-Item -Path wrappers.zip\n</code></pre> <p>With the wrapper scripts in place, you can start adding tools:</p> Linux/MacWindows <pre><code># initialize a PDM project\n./pw --add pdm\n./pw pdm init\n# initialize a poetry project\n./pw --add poetry\n./pw poetry init\n</code></pre> <pre><code># initialize a PDM project\npw --add pdm\npw pdm init\n# initialize a poetry project\npw --add poetry\npw poetry init\n</code></pre> <p>Tip: Add the wrapper scripts to version control</p> <p>When using Git: <pre><code>git add pw pw.bat\ngit update-index --chmod=+x pw\necho .pyprojectx/ &gt;&gt; .gitignore\n</code></pre></p> <p>Tip: Install the <code>px</code> utility script</p> <p>You can copy a small script to <code>.pyprojectx</code> in your home directory. When added to your PATH, you can replace <code>./pw</code> with the shorter <code>px</code>. This also works from subdirectories: <code>../../pw</code> can also be replaced with <code>px</code></p> Linux/MacWindows <pre><code>./pw --install-px\n</code></pre> <pre><code>pw --install-px\n</code></pre>"},{"location":"dev-dependencies/","title":"A Note about Dev-Dependencies","text":"<p>Poetry and PDM let you define dev-dependencies similar to npm's devDependencies. There is however a major difference between Python and npm dependencies: npm can install multiple versions of the same package, meaning that devDependencies do not interfere with main dependencies. Python, on the other hand, can only install one version of a package. This means that all dependencies will have to meet both the main dependency constraints and all the dev-dependency constraints.</p> <p>If you install all your development tools as dev-dependencies, some packages that your production code depends on, will likely be downgraded to older versions. Or worse: your project fails to install because of dependency conflicts.</p> <p>Tip: Only install test packages as dev-dependencies</p> <p>pytest and friends need to be installed together with your code, so you will need to add them as Poetry or PDM dev-dependencies. Other tools and utilities can be managed by Pyprojectx in order to get reproducible builds.</p>"},{"location":"dev-dependencies/#the-unreliable-pip-install","title":"The unreliable pip install","text":"<p>One would expect that <code>pip install tool-x==1.2.3</code> always installs exactly the same version of tool-x. Unfortunately, this is not the case because a most python packages do not pin the versions of their dependencies.</p> <p>This means that released versions of tools can be broken at any time by a new release of one of their dependencies.</p> <p>This is exactly what happened with PDM 2.5.3.</p> <p>For this reason, all the dependencies of pyprojectx are locked when publishing to PyPI.</p>"},{"location":"recipes/","title":"Recipes","text":""},{"location":"recipes/#create-a-new-project","title":"Create a new project","text":"<p>Install common tools: - pdm or poetry: dependency management (see simple projects if not required). - ruff: linter/formatter - pre-commit: git hooks for formatting and linting - px-utils: cross-platform file operations</p> Linux/Mac <pre><code># initialize a PDM project\n./pw --add pdm,ruff,pre-commit,px-utils\n./pw pdm init\n# initialize a poetry project\n./pw --add poetry,ruff,pre-commit,px-utils\n./pw poetry init\n</code></pre> Windows <pre><code># initialize a PDM project\npw --add pdm,ruff,pre-commit,px-utils\npw pdm init\n# initialize a poetry project\npw --add poetry,ruff,pre-commit,px-utils\npw poetry init\n</code></pre>"},{"location":"recipes/#simple-projects","title":"Simple projects","text":"<p>If you don't need dependency management (f.e. when you don't have any dependencies), Pyprojectx can create your virtual environment and install test dependencies.</p> <pre><code>[tool.pyprojectx]\n[tool.pyprojectx.main]\nrequirements = [\"pre-commit\", \"black\", \"isort\", \"mypy\", \"px-utils\"]\npost-install = \"pre-commit install &amp;&amp; pw@ --install-context venv\"\n\n[tool.pyprojectx.venv]\ndir = \"@PROJECT_DIR/.venv\"\n# install your project in editable mode; this assumes that your project is installable\nrequirements = [\"pytest==8.0.0\", \"-e .\"]\n\n[tool.pyprojectx.aliases]\nformat = [\"black src\", \"isort src\"]\nlint = \"mypy --python-executable .venv/bin/python --no-incremental\"\ntest = { cmd = \"pytest\", ctx = \"venv\" }\n</code></pre> <p>After running any alias (f.e. <code>./pw test</code>), you can activate the virtual environment with <code>source .venv/bin/activate</code>.</p> <p>Use the <code>-f</code> of <code>--force-install</code> flag to recreate the virtual environment after changing the requirements in <code>[tool.pyprojectx.venv]</code>, f.e. run <code>./pw -f test</code>.</p>"},{"location":"recipes/#build-scripts","title":"Build scripts","text":"<p>Script your development and build flow with aliases:</p> <ul> <li>use pre-commit hooks</li> <li>configure code formatting and linting</li> <li>package and publish to pypi</li> <li>...</li> </ul> <p>Use Poetry or PDM to further streamline your development flow with:</p> <ul> <li>better dependency management and version locking compared with pip requirement files</li> <li>virtual environment management (or skip a virtual environment all together when using PDM)</li> <li>packaging and publishing</li> </ul> <p>With this combination, you can most likely skip makefiles altogether.</p> <p>Example:</p> PDMPoetry <pre><code>[tool.pyprojectx]\n[tool.pyprojectx.main]\nrequirements = [ \"pdm\", \"ruff\", \"pre-commit\", \"px-utils\", \"mkdocs\" ]\n# the first time that a pdm command is invoked, we make sure that pre-commit hooks are installed, so we can't forget it\npost-install = \"pre-commit install\"\n[tool.pyprojectx.aliases]\n# create the virtual environment and install all dependencies\ninstall = \"pdm install\"\n# run a command in the project's virtual environment\nrun = \"pdm run\"\n# show outdated dependencies\noutdated = \"pdm update --outdated\"\nclean = \"pxrm .venv .pytest_cache dist .pdm-build .ruff_cache\"\nfull-clean = [\"@clean\", \"pxrm .pyprojectx\"]\n# format code and sort imports\nformat = [\"ruff format\", \"ruff check --select I --fix\"]\nlint = [\"ruff check\"]\ntest = \"pdm run pytest\"\n# run check before pushing to git and your build will never break\ncheck = [\"@lint\", \"@test\"]\n# run the same build command on your laptop or CI/CD server\nbuild = [ \"@install\", \"@check\", \"pdm build\" ]\n# extract complexity from your CI/CD flows to test/run them locally\n# use comprehensible python scripts (bin/prep-release) instead of complex shell scripts\nrelease = [\"prep-release\", \"pdm publish --username __token__\"]\n</code></pre> <pre><code>[tool.pyprojectx]\n[tool.pyprojectx.main]\nrequirements = [ \"poetry\", \"ruff\", \"pre-commit\", \"px-utils\", \"mkdocs\" ]\n# the first time that a poetry command is invoked, we make sure that pre-commit hooks are installed, so we can't forget it\npost-install = \"pre-commit install\"\n[tool.pyprojectx.aliases]\n# create the virtual environment and install all dependencies\ninstall = \"poetry install\"\n# run a command in the project's virtual environment\nrun = \"poetry run\"\n# show outdated dependencies\noutdated = \"poetry show --outdated --top-level\"\nclean = \"pxrm .venv .pytest_cache dist .ruff_cache\"\nfull-clean = [\"@clean\", \"pxrm .pyprojectx\"]\n# format code and sort imports\nformat = [\"ruff format\", \"ruff check --select I --fix\"]\nlint = [\"ruff check\"]\ntest = \"poetry run pytest\"\n# run check before pushing to git and your build will never break\ncheck = [\"@lint\", \"@test\"]\n# run the same build command on your laptop or CI/CD server\nbuild = [ \"@install\", \"@check\", \"poetry build\" ]\n# extract complexity from your CI/CD flows to test/run them locally\n# use comprehensible python scripts (bin/prep-release) instead of complex shell scripts\nrelease = [\"prep-release\", \"poetry publish --username __token__\"]\n</code></pre> <p>See Pyprojectx own pyproject.toml for a full example with PDM, or px-demo for another example project with PDM or the poetry variant.</p> <p>Tip: Keep the poetry virtual environment inside your project directory</p> <p>Add <code>poetry.toml</code> to your project: <pre><code>[virtualenvs]\nin-project = true\n</code></pre> This makes Poetry create a <code>.venv</code> in your project directory instead of somewhere in your home directory. It makes it easier to locate files and to keep your system clean when removing the project.</p>"},{"location":"recipes/#github-actions","title":"Github actions","text":"<p>By using the <code>pw</code> wrapper script, you can simplify your github actions:</p> <ul> <li>no explicitly tool installations or docker images (for Python tools)</li> <li>use the same commands and scripts in github actions as on your laptop</li> </ul> <p>Some tips:</p> <ul> <li>Use the same scripts on Linux and Windows by replacing <code>./pw</code> (resp. <code>pw</code>) with <code>python pw</code></li> <li>Speed up builds by caching <code>.pyprojectx</code></li> </ul> <p>Example: <pre><code>jobs:\n  build:\n    steps:\n      - name: Cache .pyprojectx\n        uses: actions/cache@v2\n        env:\n          cache-name: .pyprojectx\n        with:\n          path: .pyprojectx\n          key: ${{ runner.os }}-pyprojectx\n\n      - name: Set up Python ${{ matrix.python-version }} on ${{ matrix.os }}\n        uses: actions/setup-python@v2\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Test and build\n        run: python pw build\n</code></pre> See Pyprojectx own build and release workflows for a full example.</p>"},{"location":"recipes/#experiment-with-your-project-in-a-jupyter-notebook","title":"Experiment with your project in a Jupyter notebook","text":"<p>You can launch a notebook that has access to your project packages without the need to install anything upfront.</p> <p><pre><code>[tool.pyprojectx]\n# install the current project in editable mode, together with jupyter\njupyter = [\"jupyterlab\", \"-e .\"]\n\n[tool.pyprojectx.aliases]\n# -y is there to automatically answer 'yes' after quitting with ctrl+c\nnotebook = \"jupyter lab -y\"\n</code></pre> Just run <code>px notebook</code> or even <code>px n</code></p> <p>Editable installs are not locked</p> <p>When a tool context contains an editable install, it won't be locked when running <code>./pw --lock</code>. Therefore, it is recommended to add editable install to a separate tool context and lock the main context fro reproducible builds.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#cli","title":"CLI","text":"<pre><code>usage: pw.py [-h] [--version] [--toml TOML] [--install-dir INSTALL_DIR]\n             [--force-install] [--install-context tool-context] [--verbose]\n             [--quiet] [--info] [--add [context:]&lt;package&gt;,&lt;package&gt;...]\n             [--lock] [--install-px] [--upgrade]\n             ...\n\nExecute commands or aliases defined in the [tool.pyprojectx] section of\npyproject.toml. Use the -i or --info option to see available tools and\naliases.\n\npositional arguments:\n  command               The command/alias with optional arguments to execute.\n\noptions:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n  --toml TOML, -t TOML  The toml config file. Defaults to 'pyproject.toml' in\n                        the same directory as the pw script.\n  --install-dir INSTALL_DIR\n                        The directory where all tools (including pyprojectx)\n                        are installed; defaults to the PYPROJECTX_INSTALL_DIR\n                        environment value if set, else '.pyprojectx' in the\n                        same directory as the invoked pw script\n  --force-install, -f   Force clean installation of the virtual environment\n                        used to run cmd, if any\n  --install-context tool-context\n                        Install a tool context without actually running any\n                        command.\n  --verbose, -v         Give more output. This option is additive and can be\n                        used up to 2 times.\n  --quiet, -q           Suppress output\n  --info, -i            Show the configuration details of a command instead of\n                        running it. If no command is specified, a list with\n                        all available tools and aliases is shown.\n  --add [context:]&lt;package&gt;,&lt;package&gt;...\n                        Add one or more packages to a tool context. If no\n                        context is specified, the packages are added to the\n                        main context. Packages can be specified as in 'pip\n                        install', except that a ',' can't be used in the\n                        version specification.\n  --lock                Write all dependencies of all tool contexts to\n                        'pw.lock' to guarantee reproducible outcomes.\n  --install-px          Install the px and pxg scripts in your home directory.\n  --upgrade             Print instructions to download the latest pyprojectx\n                        wrapper scripts.\n</code></pre>"},{"location":"usage/#install-the-global-px-script","title":"Install the global <code>px</code> script","text":"<p>Pyprojectx provides a small <code>px</code> script that delegates everything to the <code>pw</code> wrapper script. The <code>pw</code> script is searched for in the current working directory and its parents.</p> <p>When added to your PATH, you can replace <code>./pw</code> with the shorter <code>px</code>. This also works from subdirectories: <code>../../pw</code> can also be replaced with <code>px</code></p> <p>To install:</p> Linux/MacWindows <pre><code>./pw --install-px\n</code></pre> <pre><code>pw --install-px\n</code></pre>"},{"location":"usage/#global-tools","title":"Global tools","text":"<p>Besides the <code>px</code> script, <code>pw --install-px</code> also copies adds the <code>pxg</code>.</p> <p><code>pxg</code> can be used as a lightweight pipx to install/run tools globally.</p> <p>Example: make http requests with httpie: <pre><code>pxg --add httpie\npxg http POST pie.dev/post hello=world\n</code></pre></p> <p>The global setup can be configured in ~/.pyprojectx/global/pyproject.toml.</p> <p>Uninstalling all global tools is just a matter of removing the global directory: <pre><code>rm -rf ~/.pyprojectx/global/.pyprojectx\n</code></pre></p>"},{"location":"config/aliases/","title":"Shortcut common commands with aliases","text":"<p>Aliases allow you to define shortcuts for common commands and simple shell scripts.</p> <p><code>px</code> or <code>pw</code>?</p> <p>This section assumes that you installed the px utility script. Otherwise, you need to replace <code>px</code> with <code>./pw</code> (Linux, Mac) or <code>pw</code> (Windows PowerShell).</p>"},{"location":"config/aliases/#defining-shortcuts","title":"Defining shortcuts","text":"<p>You can avoid a lot of typing by aliasing commands that you use a lot. Example:</p> <pre><code>[tool.pyprojectx.aliases]\ninstall = \"poetry install\"\nrun = \"poetry run\"\n</code></pre> <p>With above aliases, you can type <code>px install</code> instead of the usual <code>poetry install</code>. Depending on your other aliases, this can be even shortened to <code>px i</code> (see alias abbreviations).</p> <p>All arguments are passed to the underlying command or script, making <code>px run my-script --foo</code> equivalent to <code>poetry run my-script --foo</code>.</p>"},{"location":"config/aliases/#shell-scripts","title":"Shell scripts","text":"<p>Shell scripts can also be aliased:</p> <pre><code>[tool.pyprojectx.aliases]\nprepare = \"mkdir build &amp;&amp; mkdir generated\"\nclean = \"rm -rf build generated\"\n</code></pre> <p>You can override aliases for a specific OS:</p> <pre><code>[tool.pyprojectx.os.win.aliases]\nclean = \"rd /s /q build generated\"\n</code></pre> <p>Above <code>clean</code> alias will override the default one on Windows (in fact on all operating systems where <code>sys.platform.startswith(\"win\")==True</code>).</p> <p>Tip: use px-utils for common file operations</p> <p>Use px-utils to create, copy, move, delete, ... files and directories cross-platform. <pre><code>[tool.pyprojectx.os.win.aliases]\nclean = \"pxrm build generated\"\n</code></pre></p> <p>Aliases are interpreted by the OS shell</p> <p>The alias <code>show-path = \"echo %PATH%\"</code> will print the PATH environment variable on Windows, but will print literally <code>%PATH%</code> on another OS.</p>"},{"location":"config/aliases/#combining-aliases","title":"Combining aliases","text":"<p>Use the <code>@</code> prefix to call an alias or script from another alias.</p> <pre><code>[tool.pyprojectx.aliases]\nunit-test = \"pdm run pytest tests/unit\"\nintegration-test = \"pdm run pytest tests/integration\"\ntest = [\"@unit-test &amp;&amp; @integration-test\"]\n# a list of commands behaves the same as when combined with '&amp;&amp;'\nbuild = [\n    \"@install\",\n    \"@test\",\n    \"@pdm build\",\n]\n</code></pre> <p><code>[pw]@</code> is substituted with the initial wrapper command + arguments.</p> <p>So running <code>px -v test</code> will expand to</p> <pre><code>px -v poetry run pytest tests/unit &amp;&amp; px -v  poetry run pytest tests/integration\n</code></pre>"},{"location":"config/aliases/#alias-configuration","title":"Alias configuration","text":"<p>Besides simple commands, aliases provide some configuration options:</p> <pre><code>notebook = { cmd = 'jupyter lab', ctx = 'jupyter', env = { JUPYTERLAB_DIR = \"docs\" } }\n</code></pre> <ul> <li><code>cmd</code>: the command to run</li> <li><code>ctx</code>: the tool context in which the command is run; defaults to <code>main</code></li> <li><code>env</code>: additional environment variables to set</li> <li><code>cwd</code>: the working directory in which the command is run; defaults to @PROJECT_DIR, the directory containing     pyproject.toml. This default ensures that commands can be run from any subdirectory of the project.     Use @PROJECT_DIR/subdir to run the command in a subdirectory of the project.</li> <li><code>shell</code>: the shell used to run the command, overrides the default shell of the tool context</li> </ul> <p>Default CWD changed in 2.0.0</p> <p>Prior to Pyprojectx 2.0.0, aliases where always executed in the current working directory. As of 2.0.0, aliases run by default in the root directory of the project (where pyproject.toml is located), unless explicitly overridden with the <code>cwd</code> option.</p>"},{"location":"config/aliases/#abbreviations","title":"Abbreviations","text":"<p>To run an alias, you only have to type the portion of the alias name that uniquely identifies the alias within the project. So we don't have to type the complete name if we can use a shorter version. As a bonus Pyprojectx also supports camel case to abbreviate an alias name.</p> <p>When you define an alias named either <code>foo-bar</code> or <code>fooBar</code>, then following commands are equivalent (provided they don't match any other alias):</p> <pre><code>px foo-bar\npx fooBar\npx fooB\npx fBar\npx fB\npx f\n</code></pre> <p>An alias can shadow other commands</p> <p>Abbreviations come with the cost that an alias will shadow other non-alias commands when the alias' name starts with that command. For example: <pre><code>[tool.pyprojectx]\nmain = [\"black\"]\n[tool.pyprojectx.aliases]\nblack-adder = \"echo 'Field Marshal Haig is about to make yet another gargantuan effort to move his drinks cabinet six inches closer to Berlin.'\"\nblack = \"black\"\n</code></pre> Here it would not be possible to use the <code>black</code> formatter without explicitly exposing it with the second alias.</p> <p>Tip: Abbreviations as cli hints</p> <p>When you don't remember the exact alias to run, just type the first letter(s) and <code>px</code> will refresh your memory \ud83d\ude01 <pre><code>px c\n# 'c' is ambiguous\n# Candidates are:\n# clean, clean-all, check\n</code></pre> Or run <code>px -i</code> to list all available aliases and tools.</p>"},{"location":"config/defaults/","title":"Configurable defaults","text":""},{"location":"config/defaults/#current-working-directory","title":"Current working directory","text":"<p>You can change the default working directory for all commands by setting the <code>cwd</code> option.</p> <p>Sensible values are <code>.</code> (the current directory) or <code>@PROJECT_DIR</code> (the directory containing pyproject.toml).</p> <pre><code>[tool.pyprojectx]\ncwd = \".\"\n</code></pre> <p>Aliases can override the global cwd.</p>"},{"location":"config/defaults/#environment-variables","title":"Environment variables","text":"<p>You can set environment variables that will be added to the system environment when running a command:</p> <pre><code>[tool.pyprojectx]\nenv = { POETRY_VIRTUALENVS_PATH = \"/data/poetry\" }\n</code></pre> <p>Aliases can provide additional environment variables and/or override the global ones.</p>"},{"location":"config/defaults/#shell","title":"Shell","text":"<p>You can change the os shell used to run commands. The shell can be defined globally, os specific or alias specific.</p> <pre><code>[tool.pyprojectx]\nshell = \"bash\n[tool.pyprojectx.os.win]\nshell = \"pwsh.exe\"\n</code></pre> <p>Specifying a shell changes variable substitution</p> <p>Commands are converted into a single string and passed to the shell with the <code>-c</code> option, example: <code>bash -c \"echo $PATH\"</code>. This changes the variable substitution that is done by your os and can lead to unexpected results.</p> <p>When you set a shell for os specific file operations, consider using px-utils instead. <pre><code>[tool.pyprojectx.alias]\nprepare = \"pxmkdirs build generated\"\ncopy = \"pxcp src/**/*.py build/python\"\nmove = \"pxmv data/**/*.json build/data\"\nclean = \"pxrm build generated\"\n</code></pre></p>"},{"location":"config/scripts/","title":"Run Python scripts","text":"<p>Logic that is too complex to embed in pyproject.toml can be written in Python scripts in the bin directory. These can be called from aliases or from the command line with <code>pw &lt;script-name&gt;</code>.</p> <p>The scripts run by default in the main tool context and hence can use all libraries installed in the main tool context.</p> <p>To run a script in a different tool context, you need to define an alias:</p> <pre><code>[tool.pyprojectx.aliases]\n# run the generate-data script in the 'jupyter' tool context\ngenerate-data = { cmd = 'generate-data', ctx = 'jupyter' }\n</code></pre> <p>The script directory can be changed with the <code>scripts_dir</code> option in pyproject.toml:</p> <pre><code>[tool.pyprojectx]\nscripts_dir = \"scripts\"\n</code></pre>"},{"location":"config/tools/","title":"Manage tools as dev dependencies","text":"<p>Pyprojectx can manage all the Python tools and utilities that you use for building, testing...</p> <p>Adding tools to the <code>[tool.pyprojectx]</code> section in <code>pyproject.toml</code> makes them available inside your project.</p> <p>Tool contexts introduced in Pyprojectx 2.0.0</p> <p>Prior to Pyprojectx 2.0.0, tools were always installed in a separate virtual environment. As of 2.0.0, tools are by default installed in the virtual environment of the main tool context.</p> <p><code>px</code> or <code>pw</code>?</p> <p>This section assumes that you installed the px utility script. Otherwise, you need to replace <code>px</code> with <code>./pw</code> (Linux, Mac) or <code>pw</code> (Windows PowerShell).</p>"},{"location":"config/tools/#tool-contexts","title":"Tool contexts","text":"<p>Pyprojectx creates an isolated virtual environment for each tool context (set of tools).</p> <p>Inside the <code>[tool.pyprojectx]</code> section of <code>pyproject.toml</code> you specify what needs to be installed.</p> pyproject.toml<pre><code>[tool.pyprojectx]\n# require a specific poetry version, use the latest version of black\nmain = [\"poetry==1.1.11\", \"black\"]\n</code></pre> <p>Above configuration makes the <code>black</code> and <code>poetry</code> commands available inside your project.</p> <p>You only need to prefix them with the<code>px</code> or <code>pw</code> wrapper script:</p> Any OS with <code>px</code>Linux/MacWindows <pre><code>px poetry --help\npx black my_package --diff\n</code></pre> <pre><code>./pw poetry --help\n./pw black my_package --diff\n</code></pre> <pre><code>pw poetry --help\npw black my_package --diff\n</code></pre> <p>Naming your tool context</p> <p>When running a command that has the same name as a tool context, the command will be executed by default inside the virtual environment of that tool context. Otherwise, the command will be executed in the virtual environment of the main tool context.</p>"},{"location":"config/tools/#tool-context-configuration","title":"Tool context configuration","text":"<p>In its simplest form, a tool context is a multiline string or array of strings that adheres to pip's Requirements File Format</p> <p>Example:</p> pyproject.toml<pre><code>[tool.pyprojectx]\nmain = [\"pdm\",\"ruff\",\"pre-commit\",\"px-utils\"]\nhttp = \"httpie ~= 3.0\"\n</code></pre> <p>With above configuration, you can run following commands:</p> <pre><code>px pdm --version\n# PDM, version 2.11.2\npx http www.google.com\n# HTTP/1.1 200 OK ...\n</code></pre> <p>Tip: Specify exact versions for tools that are critical in your build flow</p> <p>This makes sure that your build won't break when new versions of a tool are released. It also ensures that you can always rebuild older versions of your project that rely on older versions of tools (f.e. when building a patch release).</p>"},{"location":"config/tools/#post-install-scripts","title":"Post-install scripts","text":"<p>In some situations it can be useful to perform additional actions after a tool has been installed. This is achieved by configuring both requirements and post-install scripts for a tool</p> <pre><code>[tool.pyprojectx]\n[tool.pyprojectx.main]\nrequirements = [\"pdm\", \"ruff\", \"pre-commit\", \"px-utils\"]\npost-install = \"pre-commit install\"\n</code></pre> <p>When creating your project's virtual environment with <code>px pdm install</code> for the first time in the example above, pre-commit is also initialised. This makes sure that pre-commit hooks are always run when committing code.</p> <p>Tip: Use toml subsections for better readability</p> <p>The example above uses a toml subsection instead of an inline table: <pre><code>main = { requirements = [...], post-install=\"...\"}`\n</code></pre></p>"},{"location":"config/tools/#using-an-alternative-package-index","title":"Using an alternative package index","text":"<p>You can use pip's <code>--index-url</code> or <code>--extra-index-url</code> to install packages from alternative (private) package indexes:</p> <pre><code>[tool.pyprojectx]\nprivate-tool = [\n    \"--extra-index-url https://artifactory.acme.com/artifactory/api/pypi/python-virtual/simple\",\n    \"some-private-package\"\n]\n</code></pre>"},{"location":"config/tools/#locking-requirements","title":"Locking requirements","text":"<p>To achieve reproducible builds, you can lock the versions of all tools that you use in your project by:</p> <ul> <li>creating a pw.lock file</li> <li>pinning tool versions in pyproject.toml</li> </ul>"},{"location":"config/tools/#creating-a-pwlock-file","title":"Creating a pw.lock file","text":"<p>When you run <code>px --lock</code>, a pw.lock file is created in the root directory of your project. This file should be committed to version control.</p> <p>This is the recommended way to lock tool versions to guarantee reproducible builds (see why)</p> <p>The lock file is automatically updated when the tool context requirements in pyproject.toml change or when you run <code>px --lock</code> again.</p> <p>Tip: don't specify tool versions in pyproject.toml when using a pw.lock file</p> <p>When there is no version specified for a tool, the latest version will be installed and locked. Updating all tools to the latest version is then as simple as running <code>px --lock</code> again. In case of conflicts or issues with a new version, you can always revert to the previous version of the lock file.</p> <p>Supporting multiple python versions</p> <p>Make sure to run <code>px --lock</code> using the minimum supported python version for your project. This prevents the lock file from containing dependencies that are incompatible with older python versions.</p>"},{"location":"config/tools/#pinning-tool-versions-in-pyprojecttoml","title":"Pinning tool versions in pyproject.toml","text":"<p>You can also pin tool versions in pyproject.toml:</p> <p><pre><code>[tool.pyprojectx]\nmain = [\"pdm==2.11.2\", \"ruff==0.1.11\", \"pre-commit==3.6.0\", \"px-utils==1.0.1\"]\n</code></pre> Be aware that even with a fixed version, tools can break at future installs!</p>"}]}