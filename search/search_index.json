{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ALL-INCLUSIVE PYTHON PROJECTS Introduction # Pyprojectx makes it easy to create all-inclusive Python projects; no need to install any tools upfront, not even Pyprojectx itself! Feature highlights # Reproducible builds by treating tools and utilities as (versioned) dev-dependencies No global installs, everything is stored inside your project directory (like npm's node_modules ) Bootstrap your entire build process with a small wrapper script (like Gradle's gradlew wrapper) Configure shortcuts for routine tasks Simple configuration in pyproject.toml Projects can be build/tested/used immediately without explicit installation nor initialization: Linux/Mac Windows git clone https://github.com/pyprojectx/px-demo.git cd px-demo ./pw build git clone https :// github . com / pyprojectx / px-demo . git cd px-demo pw build Installation # One of the key features is that there is no need to install anything explicitly (except a Python 3.7+ interpreter). cd into your project directory and download the wrapper scripts : Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip With the wrapper scripts in place, you can generate example configuration (see Initialize a new or existing project ): Linux/Mac Windows # initialize a plain Python project ./pw --init project # initialize a project with poetry's init command ./pw --init poetry # initialize a project with pdm's init command ./pw --init pdm # initialize a plain Python project pw - -init project # initialize a project with poetry's init command pw - -init poetry # initialize a project with pdm's init command pw - -init pdm Tip: Add the wrapper scripts to version control When using Git: git add pw pw.bat git update-index --chmod = +x pw echo .pyprojectx/ >> .gitignore Tip: Install the px utility script You can copy a small script to .pyprojectx in your home directory. When added to your PATH , you can replace ./pw with the shorter px . This also works from subdirectories: ../../pw can also be replaced with px Linux/Mac Windows ./pw --init global pw - -init global","title":"Home"},{"location":"#introduction","text":"Pyprojectx makes it easy to create all-inclusive Python projects; no need to install any tools upfront, not even Pyprojectx itself!","title":"Introduction"},{"location":"#feature-highlights","text":"Reproducible builds by treating tools and utilities as (versioned) dev-dependencies No global installs, everything is stored inside your project directory (like npm's node_modules ) Bootstrap your entire build process with a small wrapper script (like Gradle's gradlew wrapper) Configure shortcuts for routine tasks Simple configuration in pyproject.toml Projects can be build/tested/used immediately without explicit installation nor initialization: Linux/Mac Windows git clone https://github.com/pyprojectx/px-demo.git cd px-demo ./pw build git clone https :// github . com / pyprojectx / px-demo . git cd px-demo pw build","title":"Feature highlights"},{"location":"#installation","text":"One of the key features is that there is no need to install anything explicitly (except a Python 3.7+ interpreter). cd into your project directory and download the wrapper scripts : Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip With the wrapper scripts in place, you can generate example configuration (see Initialize a new or existing project ): Linux/Mac Windows # initialize a plain Python project ./pw --init project # initialize a project with poetry's init command ./pw --init poetry # initialize a project with pdm's init command ./pw --init pdm # initialize a plain Python project pw - -init project # initialize a project with poetry's init command pw - -init poetry # initialize a project with pdm's init command pw - -init pdm Tip: Add the wrapper scripts to version control When using Git: git add pw pw.bat git update-index --chmod = +x pw echo .pyprojectx/ >> .gitignore Tip: Install the px utility script You can copy a small script to .pyprojectx in your home directory. When added to your PATH , you can replace ./pw with the shorter px . This also works from subdirectories: ../../pw can also be replaced with px Linux/Mac Windows ./pw --init global pw - -init global","title":"Installation"},{"location":"dev-dependencies/","text":"A Note about Dev-Dependencies # Poetry and PDM let you define dev-dependencies similar to npm's devDependencies . There is however a major difference between Python and npm dependencies: npm cam install multiple versions of the same package, meaning that devDependencies do not interfere with main dependencies. Python, on the other hand, can only install one version of a package. This means that all dependencies will have to meet both the main dependency constraints and all the dev-dependency constraints. If you install al your development tools as dev-dependencies, some packages that your production code depends on, will likely be downgraded to older versions. Or worse: your project fails to install because of dependency conflicts. Tip: Only install test packages as dev-dependencies pytest and friends need to be installed together with your code, so you will need to add them as Poetry or PDM dev-dependencies. Other tools and utilities can be managed by Pyprojectx in order to get reproducible builds.","title":"Dev Dependencies"},{"location":"dev-dependencies/#a-note-about-dev-dependencies","text":"Poetry and PDM let you define dev-dependencies similar to npm's devDependencies . There is however a major difference between Python and npm dependencies: npm cam install multiple versions of the same package, meaning that devDependencies do not interfere with main dependencies. Python, on the other hand, can only install one version of a package. This means that all dependencies will have to meet both the main dependency constraints and all the dev-dependency constraints. If you install al your development tools as dev-dependencies, some packages that your production code depends on, will likely be downgraded to older versions. Or worse: your project fails to install because of dependency conflicts. Tip: Only install test packages as dev-dependencies pytest and friends need to be installed together with your code, so you will need to add them as Poetry or PDM dev-dependencies. Other tools and utilities can be managed by Pyprojectx in order to get reproducible builds.","title":"A Note about Dev-Dependencies"},{"location":"recipes/","text":"Recipes # Build scripts # Script your development and build flow with aliases: use pre-commit hooks configure code formatting and linting package and publish to pypi ... Use Poetry or PDM to further streamline your development flow with: better dependency management and version locking compared with pip requirement files virtual environment management (or skip a virtual environment all together when using PDM) packaging and publishing With this combination, you can most likely skip makefiles altogether. Example: [tool.pyprojectx] # the first time that a poetry command is invoked, we make sure that pre-commit hooks are installed, so we can't forget it poetry = { requirements = \"poetry==1.1.13\" , post-install = \"pw@pre-commit install\" } black = \"black==22.1.0\" isort = \"isort==5.10.1\" pylint = \"pylint==2.12.2\" pre-commit = \"pre-commit\" mkdocs = [ \"mkdocs ~=1.2\" , \"mkdocs-material ~=8.2\" , \"mkdocstrings[python] ~=0.18\" , \"markdown-include ~=0.6\" , ] [tool.pyprojectx.aliases] install = \"poetry install\" run = \"poetry run pyprojectx -t pyproject.toml \" outdated = \"poetry show --outdated\" clean = \"rm -r .venv .pytest_cache dist\" black = \"black src tests\" isort = \"isort src tests\" unit-test = \"poetry run pytest tests/unit\" integration-test = \"poetry run pytest tests/integration\" test = \"pw@unit-test && pw@integration-test\" check-pylint = \"pylint src tests\" check-black = \"black src tests --check\" # run check before pushing to git and your build will never break check = \"pw@check-black && pw@check-pylint && pw@test\" # run the same build command on your laptop or CI/CD server build = \"pw@install && pw@check && pw@poetry build\" # extract complexity from your CI/CD flows to test/run locally publish = \"poetry publish --username __token__\" prep-release = \"\"\"\\ # create distributions, tag versions, etc. \"\"\" # generate documentation generate-usage = \"pw@ --help > docs/docs/usage.txt\" serve-docs = \"@mkdocs: cd docs && mkdocs serve\" deploy-docs = \"@mkdocs: cd docs && mkdocs gh-deploy\" See Pyprojectx own pyproject.toml for a full example with Poetry, or px-demo for an example project with PDM. Github actions # By using the pw wrapper script, you can simplify your github actions: * no explicitly tool installations or docker images (for Python tools) * use the same commands and scripts in github actions as on your laptop Some tips: * Use the same scripts on Windows and Linux by replacing .pw with python pw * Speed up builds by caching .pyprojectx Example: jobs : build : steps : - name : Cache .pyprojectx uses : actions/cache@v2 env : cache-name : .pyprojectx with : path : .pyprojectx key : ${{ runner.os }}-pyprojectx - name : Set up Python ${{ matrix.python-version }} on ${{ matrix.os }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Test and build run : python pw build See Pyprojectx own build and release workflows for a full example. Experiment with your project in a Jupyter notebook # You can launch a notebook that has access to your project packages without the need to install anything upfront. [tool.pyprojectx] # install the current directory together with jupyter jupyter = [ \"jupyter\" , \".\" ] [tool.pyprojectx.aliases] # the notebook-dir is optional # -y is there to automatically answer 'yes' after quiting with ctrl+c notebook = \"jupyter notebook --notebook-dir docs -y\" Just run px notebook or even px n","title":"Recipes"},{"location":"recipes/#recipes","text":"","title":"Recipes"},{"location":"recipes/#build-scripts","text":"Script your development and build flow with aliases: use pre-commit hooks configure code formatting and linting package and publish to pypi ... Use Poetry or PDM to further streamline your development flow with: better dependency management and version locking compared with pip requirement files virtual environment management (or skip a virtual environment all together when using PDM) packaging and publishing With this combination, you can most likely skip makefiles altogether. Example: [tool.pyprojectx] # the first time that a poetry command is invoked, we make sure that pre-commit hooks are installed, so we can't forget it poetry = { requirements = \"poetry==1.1.13\" , post-install = \"pw@pre-commit install\" } black = \"black==22.1.0\" isort = \"isort==5.10.1\" pylint = \"pylint==2.12.2\" pre-commit = \"pre-commit\" mkdocs = [ \"mkdocs ~=1.2\" , \"mkdocs-material ~=8.2\" , \"mkdocstrings[python] ~=0.18\" , \"markdown-include ~=0.6\" , ] [tool.pyprojectx.aliases] install = \"poetry install\" run = \"poetry run pyprojectx -t pyproject.toml \" outdated = \"poetry show --outdated\" clean = \"rm -r .venv .pytest_cache dist\" black = \"black src tests\" isort = \"isort src tests\" unit-test = \"poetry run pytest tests/unit\" integration-test = \"poetry run pytest tests/integration\" test = \"pw@unit-test && pw@integration-test\" check-pylint = \"pylint src tests\" check-black = \"black src tests --check\" # run check before pushing to git and your build will never break check = \"pw@check-black && pw@check-pylint && pw@test\" # run the same build command on your laptop or CI/CD server build = \"pw@install && pw@check && pw@poetry build\" # extract complexity from your CI/CD flows to test/run locally publish = \"poetry publish --username __token__\" prep-release = \"\"\"\\ # create distributions, tag versions, etc. \"\"\" # generate documentation generate-usage = \"pw@ --help > docs/docs/usage.txt\" serve-docs = \"@mkdocs: cd docs && mkdocs serve\" deploy-docs = \"@mkdocs: cd docs && mkdocs gh-deploy\" See Pyprojectx own pyproject.toml for a full example with Poetry, or px-demo for an example project with PDM.","title":"Build scripts"},{"location":"recipes/#github-actions","text":"By using the pw wrapper script, you can simplify your github actions: * no explicitly tool installations or docker images (for Python tools) * use the same commands and scripts in github actions as on your laptop Some tips: * Use the same scripts on Windows and Linux by replacing .pw with python pw * Speed up builds by caching .pyprojectx Example: jobs : build : steps : - name : Cache .pyprojectx uses : actions/cache@v2 env : cache-name : .pyprojectx with : path : .pyprojectx key : ${{ runner.os }}-pyprojectx - name : Set up Python ${{ matrix.python-version }} on ${{ matrix.os }} uses : actions/setup-python@v2 with : python-version : ${{ matrix.python-version }} - name : Test and build run : python pw build See Pyprojectx own build and release workflows for a full example.","title":"Github actions"},{"location":"recipes/#experiment-with-your-project-in-a-jupyter-notebook","text":"You can launch a notebook that has access to your project packages without the need to install anything upfront. [tool.pyprojectx] # install the current directory together with jupyter jupyter = [ \"jupyter\" , \".\" ] [tool.pyprojectx.aliases] # the notebook-dir is optional # -y is there to automatically answer 'yes' after quiting with ctrl+c notebook = \"jupyter notebook --notebook-dir docs -y\" Just run px notebook or even px n","title":"Experiment with your project in a Jupyter notebook"},{"location":"usage/","text":"Usage # CLI # Initialize a new or existing project # Pyprojectx can create or update a pyproject.toml file for either a plain, a Poetry or a PDM project. Cd into your existing project directory (or create a new empty directory), download the wrapper scripts and run the init command. Plain Python project # Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init project Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init project Now you can use the px or pw script to show available tools and commands: px -i . Poetry project # Start the interactive poetry initializer: Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init poetry Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init poetry Now you can run any Poetry command with the px or pw script, f.e. px poetry install In-project virtual environment --init poetry will also copy a poetry.toml to your project directory: [virtualenvs] in-project = true This makes Poetry create a .venv in your project directory instead of somewhere in your home directory. It makes it easier to locate files and to keep your system clean when removing the project. PDM project # Start the interactive pdm initializer: Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init pdm Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init pdm Start the interactive PDM init command: px --init pdm Now you can run any pdm command with the px or pw script, f.e. px pdm install Install the global px script # Pyprojectx provides a small px script that delegates everything to the pw wrapper script. The pw script is searched in the current working directory and its parents. When added to your PATH , you can replace ./pw with the shorter px . This also works from subdirectories: ../../pw can also be replaced with px To install: Linux/Mac Windows ./pw --init global pw - -init global Global tools # Besides the px script, pw --init global also copies other files: * pxg script in ~/.pyprojectx * pw script and example pyproject.toml in ~/.pyprojectx/global pxg can be uses as a lightweight pipx to install tools globally. Example usage: pyproject.toml contains by default httpie so you can make http requests: pxg http POST pie.dev/post hello = world Uninstalling all global tools is just a matter of rm -rf ~/.pyprojectx/global/.pyprojectx","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#cli","text":"","title":"CLI"},{"location":"usage/#initialize-a-new-or-existing-project","text":"Pyprojectx can create or update a pyproject.toml file for either a plain, a Poetry or a PDM project. Cd into your existing project directory (or create a new empty directory), download the wrapper scripts and run the init command.","title":"Initialize a new or existing project"},{"location":"usage/#plain-python-project","text":"Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init project Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init project Now you can use the px or pw script to show available tools and commands: px -i .","title":"Plain Python project"},{"location":"usage/#poetry-project","text":"Start the interactive poetry initializer: Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init poetry Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init poetry Now you can run any Poetry command with the px or pw script, f.e. px poetry install In-project virtual environment --init poetry will also copy a poetry.toml to your project directory: [virtualenvs] in-project = true This makes Poetry create a .venv in your project directory instead of somewhere in your home directory. It makes it easier to locate files and to keep your system clean when removing the project.","title":"Poetry project"},{"location":"usage/#pdm-project","text":"Start the interactive pdm initializer: Linux/Mac Windows curl -LO https://github.com/pyprojectx/pyprojectx/releases/latest/download/wrappers.zip && unzip wrappers.zip && rm -f wrappers.zip ./pw --init pdm Invoke-WebRequest https :// github . com / pyprojectx / pyprojectx / releases / latest / download / wrappers . zip -OutFile wrappers . zip ; Expand-Archive -Path wrappers . zip -DestinationPath .; Remove-Item -Path wrappers . zip .\\ pw - -init pdm Start the interactive PDM init command: px --init pdm Now you can run any pdm command with the px or pw script, f.e. px pdm install","title":"PDM project"},{"location":"usage/#install-the-global-px-script","text":"Pyprojectx provides a small px script that delegates everything to the pw wrapper script. The pw script is searched in the current working directory and its parents. When added to your PATH , you can replace ./pw with the shorter px . This also works from subdirectories: ../../pw can also be replaced with px To install: Linux/Mac Windows ./pw --init global pw - -init global","title":"Install the global px script"},{"location":"usage/#global-tools","text":"Besides the px script, pw --init global also copies other files: * pxg script in ~/.pyprojectx * pw script and example pyproject.toml in ~/.pyprojectx/global pxg can be uses as a lightweight pipx to install tools globally. Example usage: pyproject.toml contains by default httpie so you can make http requests: pxg http POST pie.dev/post hello = world Uninstalling all global tools is just a matter of rm -rf ~/.pyprojectx/global/.pyprojectx","title":"Global tools"},{"location":"config/aliases/","text":"Shortcut common commands with aliases # Aliases allow you to define shortcuts for common commands and simple shell scripts. Tools that expose multiple scripts, also require aliases to make all scripts available via the pw wrapper script. px or pw ? This section assumes that you installed the px utility script . Otherwise, you need to replace px with ./pw (Linux, Mac) or pw (Windows). Defining shortcuts # You can avoid a lot of typing by aliasing commands that you use a lot. Example: [tool.pyprojectx.aliases] install = \"poetry install\" run = \"poetry run\" With above aliases, you can type px install instead of the usual poetry install . Depending on your other aliases, this can be even shortened to px i (see alias abbreviations ). All arguments are passed to the underlying command or script, making px run my-script --foo equivalent to poetry run my-script --foo . Shell scripts # Shell scripts can also be aliased: [tool.pyprojectx.aliases] prepare = \"mkdir build && mkdir generated\" clean = \"rm -rf build generated\" You can override aliases for a specific OS: [tool.pyprojectx.os.win.aliases] clean = \"rd/s /q build generated\" Above clean alias will override the default one on Windows (in fact on all operating systems where sys.platform.startswith(\"win\")==True ). Aliases are interpreted by the OS shell The alias show-path = \"echo %PATH%\" will print the PATH environment variable on Windows, but will print literally %PATH% on another OS. Combining aliases # Use the pw@ prefix to call alias from another alias. [tool.pyprojectx.aliases] unit-test = \"poetry run pytest tests/unit\" integration-test = \"poetry run pytest tests/integration\" test = \"pw@unit-test && pw@integration-test\" pw@ is substituted with the initial wrapper command + arguments. So running px -v test will expand to px -v poetry run pytest tests/unit && px -v poetry run pytest tests/integration Tools and packages with multiple scripts # When installing multiple tools/packages together, or when using a tool that installs multiple scripts, you can define aliases to expose additional scripts besides the main script. By starting an alias with @tool-name: , where tool-name is the key of a [tool.pyprojectx] entry, the alias always runs in the context of the virtual environment that is created for tool-name . [tool.pyprojectx] # available scripts: flake8, pyflakes, black, ... flake8 = [ \"flake8 ~=4.0\" , \"flake8-black ~=0.3\" ] [tool.pyprojectx.aliases] # expose black that is installed together with flake8-black black = \"@flake8: black\" Now you can run black as usual: px black --version # black, 22.1.0 (compiled: yes) Abbreviations # To run an alias, you only have to type the portion of the alias name that uniquely identifies the alias within the project. So we don't have to type the complete name if we can use a shorter version. As a bonus Pyprojectx also supports camel case to abbreviate an alias name. When you define an alias named either foo-bar or fooBar , then following commands are equivalent (provided they don't match any other alias): px foo-bar px fooBar px fooB px fBar px fB px f An alias can shadow other commands Abbreviations come with the cost that an alias will shadow other non-alias commands when the alias' name starts with that command. For example: [tool.pyprojectx] black = \"black\" [tool.pyprojectx.aliases] black-adder = \"echo 'Field Marshal Haig is about to make yet another gargantuan effort to move his drinks cabinet six inches closer to Berlin.'\" black = \"@black: black\" Here it would not be possible to use the black formatter without explicitly exposing it with the second alias. Tip: Abbreviations as cli hints When you don't remember the exact alias to run, just type the first letter(s) and px will refresh your memory \ud83d\ude01 px c # 'c' is ambiguous # Candidates are: # clean, clean-all, check Or run px -i to list all available aliases and tools.","title":"Shortcut common commands with aliases"},{"location":"config/aliases/#shortcut-common-commands-with-aliases","text":"Aliases allow you to define shortcuts for common commands and simple shell scripts. Tools that expose multiple scripts, also require aliases to make all scripts available via the pw wrapper script. px or pw ? This section assumes that you installed the px utility script . Otherwise, you need to replace px with ./pw (Linux, Mac) or pw (Windows).","title":"Shortcut common commands with aliases"},{"location":"config/aliases/#defining-shortcuts","text":"You can avoid a lot of typing by aliasing commands that you use a lot. Example: [tool.pyprojectx.aliases] install = \"poetry install\" run = \"poetry run\" With above aliases, you can type px install instead of the usual poetry install . Depending on your other aliases, this can be even shortened to px i (see alias abbreviations ). All arguments are passed to the underlying command or script, making px run my-script --foo equivalent to poetry run my-script --foo .","title":"Defining shortcuts"},{"location":"config/aliases/#shell-scripts","text":"Shell scripts can also be aliased: [tool.pyprojectx.aliases] prepare = \"mkdir build && mkdir generated\" clean = \"rm -rf build generated\" You can override aliases for a specific OS: [tool.pyprojectx.os.win.aliases] clean = \"rd/s /q build generated\" Above clean alias will override the default one on Windows (in fact on all operating systems where sys.platform.startswith(\"win\")==True ). Aliases are interpreted by the OS shell The alias show-path = \"echo %PATH%\" will print the PATH environment variable on Windows, but will print literally %PATH% on another OS.","title":"Shell scripts"},{"location":"config/aliases/#combining-aliases","text":"Use the pw@ prefix to call alias from another alias. [tool.pyprojectx.aliases] unit-test = \"poetry run pytest tests/unit\" integration-test = \"poetry run pytest tests/integration\" test = \"pw@unit-test && pw@integration-test\" pw@ is substituted with the initial wrapper command + arguments. So running px -v test will expand to px -v poetry run pytest tests/unit && px -v poetry run pytest tests/integration","title":"Combining aliases"},{"location":"config/aliases/#tools-and-packages-with-multiple-scripts","text":"When installing multiple tools/packages together, or when using a tool that installs multiple scripts, you can define aliases to expose additional scripts besides the main script. By starting an alias with @tool-name: , where tool-name is the key of a [tool.pyprojectx] entry, the alias always runs in the context of the virtual environment that is created for tool-name . [tool.pyprojectx] # available scripts: flake8, pyflakes, black, ... flake8 = [ \"flake8 ~=4.0\" , \"flake8-black ~=0.3\" ] [tool.pyprojectx.aliases] # expose black that is installed together with flake8-black black = \"@flake8: black\" Now you can run black as usual: px black --version # black, 22.1.0 (compiled: yes)","title":"Tools and packages with multiple scripts"},{"location":"config/aliases/#abbreviations","text":"To run an alias, you only have to type the portion of the alias name that uniquely identifies the alias within the project. So we don't have to type the complete name if we can use a shorter version. As a bonus Pyprojectx also supports camel case to abbreviate an alias name. When you define an alias named either foo-bar or fooBar , then following commands are equivalent (provided they don't match any other alias): px foo-bar px fooBar px fooB px fBar px fB px f An alias can shadow other commands Abbreviations come with the cost that an alias will shadow other non-alias commands when the alias' name starts with that command. For example: [tool.pyprojectx] black = \"black\" [tool.pyprojectx.aliases] black-adder = \"echo 'Field Marshal Haig is about to make yet another gargantuan effort to move his drinks cabinet six inches closer to Berlin.'\" black = \"@black: black\" Here it would not be possible to use the black formatter without explicitly exposing it with the second alias. Tip: Abbreviations as cli hints When you don't remember the exact alias to run, just type the first letter(s) and px will refresh your memory \ud83d\ude01 px c # 'c' is ambiguous # Candidates are: # clean, clean-all, check Or run px -i to list all available aliases and tools.","title":"Abbreviations"},{"location":"config/tools/","text":"Manage Tools as Dev dependencies # Pyprojectx can manage all the Python tools and utilities that you use for building, testing... Adding a tool to the [tool.pyprojectx] section in pyproject.toml makes it available inside your project. px or pw ? This section assumes that you installed the px utility script . Otherwise, you need to replace px with ./pw (Linux, Mac) or pw (Windows). Tool configuration # Pyprojectx creates an isolated virtual environment for each configured tool (or set of tools). Inside the [tool.pyprojectx] section of pyproject.toml you specify what needs to be installed. pyproject.toml [tool.pyprojectx] # require a specific poetry version poetry = \"poetry==1.1.11\" # install the latest version of the black formatter black = \"black\" Above configuration makes the black and poetry commands available inside your project. You only need to prefix them with the px or pw wrapper script: Any OS with px Linux/Mac Windows px poetry --help px black my_package --diff ./pw poetry --help ./pw black my_package --diff pw poetry - -help pw black my_package - -diff Specifying requirements # The entries in the [tool.pyprojectx] section take the form tool = requirements tool : The main command or script that comes with the tool. If the tool comes with additional commands that you want to use, you need to expose these via Pyprojectx aliases . requirements : A multiline string or array of strings that adheres to pip's Requirements File Format Example: pyproject.toml [tool.pyprojectx] # expose httpie's http script http = \"httpie ~= 3.0\" flake8 = \"\"\" flake8 >3 flake8-bugbear >=20 \"\"\" black8 = [ \"flake8 ~=4.0\" , \"flake8-black ~=0.3\" ] [tool.pyprojectx.aliases] run-flake8-with-black = \"@black8: flake8\" With above configuration, you can run following commands: px http www.google.com # HTTP/1.1 200 OK ... px flake8 --version # 4.0.1 (flake8-bugbear: 22.1.11, mccabe: 0.6.1, pycodestyle: 2.8.0, pyflakes: 2.4.0) CPython 3.9.6 on Darwin px run-flake8-with-black --version # 4.0.1 (black: 0.3.2, mccabe: 0.6.1, pycodestyle: 2.8.0, pyflakes: 2.4.0) CPython 3.9.6 on Darwin Tip: Specify exact versions for tools that are critical in your build flow This makes sure that your build won't break when new versions of a tool are released. It also ensures that you can always rebuild older versions of your project that rely on older versions of tools (f.e. when building a patch release). Using an alternative package index # You can use pip's --index-url or --extra-index-url to install packages from alternative (private) package indexes: [tool.pyprojectx] my-private-tool = [ \"--extra-index-url https://artifactory.acme.com/artifactory/api/pypi/python-virtual/simple\" , \"some-private-package\" ] Post-install scripts # In some situations it can be useful to perform additional actions after a tool has been installed. This is achieved by configuring both requirements and post-install scripts for a tool: [tool.pyprojectx] [tool.pyprojectx.jupyter] requirements = [ \"jupyter\" , \"jupyter_contrib_nbextensions\" ] post-install = \"\"\"\\ jupyter contrib nbextension install --sys-prefix jupyter nbextension enable autoscroll/main --sys-prefix jupyter nbextension enable scroll_down/main --sys-prefix\"\"\" When running px jupyter notebook for the first time in the example above, some Jupyter extensions are installed and enabled. Tip: Use toml subsections for better readability The example above uses a toml subsection instead of an inline table: jupyter = { requirements = [...], post-install = \"...\" } `","title":"Manage Tools as Dev dependencies"},{"location":"config/tools/#manage-tools-as-dev-dependencies","text":"Pyprojectx can manage all the Python tools and utilities that you use for building, testing... Adding a tool to the [tool.pyprojectx] section in pyproject.toml makes it available inside your project. px or pw ? This section assumes that you installed the px utility script . Otherwise, you need to replace px with ./pw (Linux, Mac) or pw (Windows).","title":"Manage Tools as Dev dependencies"},{"location":"config/tools/#tool-configuration","text":"Pyprojectx creates an isolated virtual environment for each configured tool (or set of tools). Inside the [tool.pyprojectx] section of pyproject.toml you specify what needs to be installed. pyproject.toml [tool.pyprojectx] # require a specific poetry version poetry = \"poetry==1.1.11\" # install the latest version of the black formatter black = \"black\" Above configuration makes the black and poetry commands available inside your project. You only need to prefix them with the px or pw wrapper script: Any OS with px Linux/Mac Windows px poetry --help px black my_package --diff ./pw poetry --help ./pw black my_package --diff pw poetry - -help pw black my_package - -diff","title":"Tool configuration"},{"location":"config/tools/#specifying-requirements","text":"The entries in the [tool.pyprojectx] section take the form tool = requirements tool : The main command or script that comes with the tool. If the tool comes with additional commands that you want to use, you need to expose these via Pyprojectx aliases . requirements : A multiline string or array of strings that adheres to pip's Requirements File Format Example: pyproject.toml [tool.pyprojectx] # expose httpie's http script http = \"httpie ~= 3.0\" flake8 = \"\"\" flake8 >3 flake8-bugbear >=20 \"\"\" black8 = [ \"flake8 ~=4.0\" , \"flake8-black ~=0.3\" ] [tool.pyprojectx.aliases] run-flake8-with-black = \"@black8: flake8\" With above configuration, you can run following commands: px http www.google.com # HTTP/1.1 200 OK ... px flake8 --version # 4.0.1 (flake8-bugbear: 22.1.11, mccabe: 0.6.1, pycodestyle: 2.8.0, pyflakes: 2.4.0) CPython 3.9.6 on Darwin px run-flake8-with-black --version # 4.0.1 (black: 0.3.2, mccabe: 0.6.1, pycodestyle: 2.8.0, pyflakes: 2.4.0) CPython 3.9.6 on Darwin Tip: Specify exact versions for tools that are critical in your build flow This makes sure that your build won't break when new versions of a tool are released. It also ensures that you can always rebuild older versions of your project that rely on older versions of tools (f.e. when building a patch release).","title":"Specifying requirements"},{"location":"config/tools/#using-an-alternative-package-index","text":"You can use pip's --index-url or --extra-index-url to install packages from alternative (private) package indexes: [tool.pyprojectx] my-private-tool = [ \"--extra-index-url https://artifactory.acme.com/artifactory/api/pypi/python-virtual/simple\" , \"some-private-package\" ]","title":"Using an alternative package index"},{"location":"config/tools/#post-install-scripts","text":"In some situations it can be useful to perform additional actions after a tool has been installed. This is achieved by configuring both requirements and post-install scripts for a tool: [tool.pyprojectx] [tool.pyprojectx.jupyter] requirements = [ \"jupyter\" , \"jupyter_contrib_nbextensions\" ] post-install = \"\"\"\\ jupyter contrib nbextension install --sys-prefix jupyter nbextension enable autoscroll/main --sys-prefix jupyter nbextension enable scroll_down/main --sys-prefix\"\"\" When running px jupyter notebook for the first time in the example above, some Jupyter extensions are installed and enabled. Tip: Use toml subsections for better readability The example above uses a toml subsection instead of an inline table: jupyter = { requirements = [...], post-install = \"...\" } `","title":"Post-install scripts"}]}